(map (fn [[k v]] "REDACTED") {:a 1 :b 2}))
(map (fn [[k v]] "REDACTED") {:a 1 :b 2})
(map (fn [[k v]] [k "REDACTED"]) {:a 1 :b 2})
(mapcat (fn [[k v]] [k "REDACTED"]) {:a 1 :b 2})
(hash-map (mapcat (fn [[k v]] [k "REDACTED"]) {:a 1 :b 2}))
(hash-map (vec (mapcat (fn [[k v]] [k "REDACTED"]) {:a 1 :b 2})))
(hash-map (cat (mapcat (fn [[k v]] [k "REDACTED"]) {:a 1 :b 2})))
(apply hash-map (mapcat (fn [[k v]] [k "REDACTED"]) {:a 1 :b 2}))
exit
(when 0 1)
(when false 1)
(when (pos? 0) 1)
EXIT
exit
(reduce #(str %1 "\n" (clojure.string/join (:values %2))) "" {:values [1 2 3]})
(reduce #(str %1 "\n" (clojure.string/join "|" (:values %2))) "" {:values [1 2 3]})
(reduce #(str %1 "\n" (clojure.string/join "|" (:values %2))) "" [{:values [1 2 3]}])
(reduce #(str %1 \newline (clojure.string/join "|" (:values %2))) "" [{:values [1 2 3]}])
(clojure.string/split "|" "|||")
(clojure.string/split #"|" "|||")
(clojure.string/split #r"|" "|||")
(clojure.string/split r"|" "|||")
(clojure.string/split "|||" #"|")
(clojure.string/split "| | |" #"|")
(clojure.string/split "| | |" #" ")
(clojure.string/split "| | |" #"\|")
(clojure.string/split "|||" #"\|")
(clojure.string/split (clojure.string/replace "|||" "|" "| ") #"\|")
(clojure.string/split (clojure.string/replace "|||" "|" " |") #"\|")
(split-at "|" "|")
(partition-by "|" "|")
(partition-by "|" (seq "|"))
(partition-by #(= % "|") "|||")
(partition-by #(= % "|") "a|a|a|")
(split-with #(= % "|") "a|a|a||||")
(split-with #(= % "|") "|a|a|a||||")
(split-with #(= % "|") "a|a|asdf||||")
(split-with (partial = "|") "a|a|asdf||||")
(split-with (partial = '|') "a|a|asdf||||")
(split-with (partial = \|) "a|a|asdf||||")
(split-with (partial not= \|) "a|a|asdf||||")
(partition-by (partial not= \|) "a|a|asdf||||")
(defn- split-with-blanks
  [line field-delimiter trailing-cell-delimiter?]
  (loop [result []
         line line]
    (if (blank? line)
      result
      (let [idx (index-of line field-delimiter)]
        (recur (conj result (subs line 0 idx))
               (subs line idx))))))
(defn- split-with-blanks
  [line field-delimiter trailing-cell-delimiter?]
  (loop [result []
         line line]
    (if (clojure.string/blank? line)
      result
      (let [idx (index-of line field-delimiter)]
        (recur (conj result (subs line 0 idx))
               (subs line idx))))))
(require 'user=> (partition-by (partial not= \|) "a|a|asdf||||")
)
(require [clojure.string :as str])
(require '[clojure.string :as str])
(defn- split-with-blanks
  [line field-delimiter trailing-cell-delimiter?]
  (loop [result []
         line line]
    (if (str/blank? line)
      result
      (let [idx (str/index-of line field-delimiter)]
        (recur (conj result (subs line 0 idx))
               (subs line idx))))))
(split-with-blanks "|||" "|" true)
(defn- split-with-blanks
  [line field-delimiter trailing-cell-delimiter?]
  (loop [result []
         line line]
    (let [idx (str/index-of line field-delimiter)]
      (if (or (nil? idx) (= (count line) 1))
        result
        (recur (conj result (subs line 0 idx))
               (subs line idx))))))
(split-with-blanks "|||" "|" true)
(require '[clojure.string :as str])
(defn- split-with-blanks
  [line field-delimiter trailing-cell-delimiter?]
  (loop [result []
         line line]
    (println result line)
    (let [idx (str/index-of line field-delimiter)]
      (if (or (nil? idx) (= (count line) 1))
        result
        (recur (conj result (subs line 0 idx))
               (subs line idx))))))
(split-with-blanks "|||" "|" true)
